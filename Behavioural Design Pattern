CHAIN OF RESPONSIBILITY:
Chain of resposibility is a design pattern where we create a chain of handlers and after completing the operation the handler will send the response to the next handler.
This is chain of resposibility.
One good example is authentication.

Also just imagine about a linked list. where each of the handler are linked using a link.

Authentication -> Authorization -> Validation -> Caching -> .......

So basically a chain of handlers.
But all the handlers must implement the same interface and have one execute method. so that we can compose the chain at run time. And avoid tight coupling.

So bascilly we will create a main interface and it will have a function called checkNext and we will have an abtract class which will implemt this interface.
This class will have the methods that are common to all other handlers.
Then we have a concrete handler that will extend this abstract class and will implement this methods.
Or we can also remove the interface and just use the abstract class as the referenec for the handlers.

Eg:
public class Main
{
	public static void main(String[] args) {
		//can do a parent to child chain
		Server server=new Server();
		Handler start=server.createChain(UserAuthenticationHandler,UserAuthorizationHandler);
		boolean result=start.check("vithesh@gmail.com","zorojuro987"); // the operation will happen in the chain
	}
}
public class Server {
	public Handler createChain(Handler start,Handler... handlers) {
	    Handler head=start;
	    for(Handler handler:handlers){
	        head.next=handler;
	        head=handler;
	    }
	    
	    return head;
	}
	
	public boolean start(String email,String password){
	    return start.check(email,password);
	}

}

public abstract class Handler {
	private Handler next;

	public abstract boolean check(String email,String password);

	public boolean checkNext(String email,String password) {
		if(next==null)return true;
		else return next.check(email,password);
	}
}

public class UserAuthenticationHandler extends Handler {
	public boolean check(String email,String password) {
		//check for authentication

		return checkNext(email,password);
	}
}

public class UserAuthorizationHandler extends Handler {
	public boolean check(String email,String password) {
		//Check for Authorization

		return checkNext(email,password);
	}
}

We can check the implementaion in 
https://refactoring.guru/design-patterns/chain-of-responsibility/java/example


Every handler must have a link to the next handler.
Its just like a linked list.
There will be one abstract class which will be extended by all these handlers.
So all these handlers know what to call.they will call that one method of that handler.
Within the concrete implementation of that handler. we can perform anu operation and have any number of methods. provided the starting and the main method is the implementation of that abstract 
method.

************************************************************************************************************************************************************************************

COMMAND:
Command design pattern creates a middle man between the  client and the server.
For example in a restraunt we have a customer,waiter, and a cook.
The client will not directly communitcate with the cook and tell him to cook. But he will tell the waiter that he wants something.
So our main focus here is seperation of concern.

public class Main
{
	public static void main(String[] args) {
		Ligt light=new Light();
		ICommand command=new LightCommand(light);
		Remote remote=new Remote(command);

		remote.pressButton();
	}
}

interface ICommand {
	public void execute();
}

class Remote {
	public ICommand command;
	public void pressButton() {
		command.execute();
	}
}

class LightCommand extends Command {
	private Light light;
	public LightCommand(Light light) {
		this.light=light;
	}
	public void execute() {
		light.toggle();
	}
}

class Light {
	private boolean lightFlag;
	public void toggle() {
		lightFlag=!lightFlag;
	}
}

Command design pattern itself is still not dynamic at runtime.
So its usually combined with factories and if the type of object tp be created is loaded from any config files.

***************************************************************************************************************************************************************************************

ITERATOR:
So basically iterator is similar to the iterator that we use in the collections. Here in each of these collections they return a new iterator 
that is used to iterate the collection.

But we dont usually use the iterators.

But the main purpose of the iterators is the seperate the internal structure of the list.

The iterator will only tell if there is any remaining element in the list. IF there is any element then we can traverse the list.

Now according to me there is one more example.
We can combine the iterator with the factory method to create a dynamic multy purpose data structure.

Lets say we have a collection that stores the element and we want to traverse the collection using the dfs. But inorder to do that we have to
manually write the logic for that. Instead of that we can assign the traversal the colleciton to a seperate object.4

We can create a collection that can store the element. Now if we want that to follow dfs traversal then we can pass the parameter to that.
So internally we will have an iterator object that can do a dfs. and this collection will return that iterator.

In future if we want to change the iteratrion stratergy we can simply add a new.
How do we do this. OPEN FOR EXTENSION AND CLOSED FOR MODIFICATION.
THIS can achived using interface polymorphism.

So basically the iterator is an iterface that has hasNext() and next() method.
Then we have a concrete class that implements this interface and traversal. How the travesal happens is upto the concrete class.

import java.util.*;
import java.lang.*;
import java.io.*;

class Codechef
{
    public static void main(String[] args) throws java.lang.Exception
    {
        Integer[]arr={1,2,3,4,5,6,7,8,9};
        ArrayList list = new ArrayList<Integer>(arr);
        
        Iterator iterator=list.getIterator("BFS");
        
        while(iterator.hasNext())
            System.out.print(iterator.next()+" ");

    }
}

class ArrayList < T > {
    T[] array;
    public ArrayList(T[]array) {
        this.array = array;
    }

    public Iterator getIterator(String itertorType) {
        switch (itertorType) {
            case "BFS":
                return new BfsIterator < T > (array);
            case "DFS":
                return new DfsIterator < T > (array);
            default:
                return null;
        }
    }
}

interface Iterator < T > {
    boolean hasNext();
    T next();
}

class DfsIterator < T > implements Iterator < T > {
    private T[] array;
    private int currentPositon;
    DfsIterator(T[] array) {
        this.array = array;
        currentPositon = 0;
    }

    public boolean hasNext() {
        return currentPositon < array.length;
    }

    public T next() {
        // We can write the further logic to make the traversal to follow dfs
        if (hasNext())
            return array[currentPositon++];
        else
            return null;
    }
}

class BfsIterator < T > implements Iterator < T > {
    private T[] array;
    private int currentPositon;
    BfsIterator(T[] array) {
        this.array = array;
        currentPositon = 0;
    }

    public boolean hasNext() {
        return currentPositon < array.length;
    }

    public T next() {
        // We can write the further logic to make the traversal to follow BFS
        if (hasNext())
            return array[currentPositon++];
        else
            return null;
    }
}

here i have created a class and i have also created a iterators. I have loosly coupled the traversing and storing of the data here.
This is the main use iterator.

*************************************************************************************************************************************
